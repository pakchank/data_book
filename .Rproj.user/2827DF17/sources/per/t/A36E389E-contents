# 부록: R과 Rstudio 설치하기 {#appendix-install}

여기서는 이 교재의 작업 환경에 해당하는 R과 Rstudio의 설치법을 설명합니다. 이 교재에서는 작업을 위한 프로그래밍 언어로 R을, 그 개발 환경으로 Rstudio를 이용합니다. 실제로 이용하는 언어는 R이지만, R 그 자체는 편리한 사용성을 제공하지 못합니다. 하지만, R이 이미 설치되어 있다면, Rstudio를 통해서 훨씬 편하고 세련된 환경에서 코딩을 할 수 있을 뿐만 아니라 R 자체로는 구현할 수 없는 중요한 추가적인 기능들을 활욯할 수 있게 됩니다. 따라서, 본 교재의 학습을 위해서는 R과 Rstudio 모두를 설치해야 합니다.

## R 설치

R을 설치하기 위해서는 [R다운로드 페이지](https://cran.yu.ac.kr/)로 이동해야 합니다.

![R 다운로드 페이지](img/download.png)

여기에서 사용하는 운영체제에 맞추어 링크를 선택합니다. 여기서는 윈도우즈 사용환경을 가정하고 '[Download R for Windows](https://cran.yu.ac.kr/bin/windows/)'를 클릭합니다. 그러면 다음과 같은 화면이 나타날 것입니다.

![윈도우즈 사용자를 위한 R 다운로드](img/windows.png) 윈도우즈 이용자들은 두 가지를 설치해야 합니다. 하나는 'base'라고 표시되어 있는 R프로그램 그 자체입니다. 해당 하이퍼링크를 클릭하면 이동하는 페이지에 'Download R-4.3.1 for Windows'라고 표시된 하이퍼링크가 있을 것입니다 (4.3.1이라는 버전을 나타내는 숫자는 최신 업데이트에 따라 달라질 수 있습니다). 이를 클릭하면 다음 설치 파일이 다운로드 됩니다. 두번째로 다운로드 받을 파일은 위의 화면 캡춰에서 'Rtools'라고 표시되어 있는 R의 확장 프로그램 입니다. 이 역시 R의 다양한 기능을 활용하기 위해서 반드시 필요합니다. 해당 링크를 클릭하여 앞서 다운 받은 R 버전에 맞는 RTools를 다운받습니다. 예컨대 앞서 R 4.3.1버전을 다운 받았으니, 'RTools 4.3'을 다운받는 것이지요.

::: callout-note
윈도우즈 사용자는 반드시 R과 RTools 모두를 설치해야 합니다.

단, 맥 사용자는 R만 설치하면 됩니다.
:::

이제 두 설치파일을 다운로드 받은 순서대로 더블클릭하여 설치를 완료하면 됩니다. 여기서도, 한 가지 주의사항이 있습니다. R은 오픈소스 언어이기 때문에, 상업 프로그램처럼 다양한 언어를 부드럽게 처리하지못하는 경우가 있습니다. 관련해서 가장 많은 에러를 양산하는 문제 중 하나가 R이 설치된 경로상에 한글이 섞여 있는 경우 입니다. 예컨대, 윈도우즈의 이용자 이름이 자신의 이름으로 되어 있다면, 설치경로가 에러를 만들어 내는 경우가 많습니다. 따라서, 윈도우즈 이용자 이름에 알파벳이 아닌 다른 문자가 섞여 있다면, R 설치시 설정하는 모든 경로를 이용자 이름이 섞이지 않도록 적절하게 수정해 주는 것이 좋습니다.

::: callout-note
R 설치 경로는 알파벳만으로 이루어지도록 주의하세요.
:::

## Rstudio 설치
Rstudio는 오픈소스 프로젝트가 아니라 사기업인 Posit에 의해 관리되기 때문에 다운로드 및 설치가 더욱 쉽습니다. [다음 링크](https://posit.co/download/rstudio-desktop/)를 따라가서, 각자의 운영체제에 맞는 설치파일을 다운 받은 후 실행해 주면 됩니다. 다만, Rstuio의 설치는 R 설치가 모두 완료된 다음 해 주는 것이 불필요한 에러를 방지할 수 있습니다.





R은 통계학자들이 만든 언어입니다. 원래는 S라는 유명한 Bell Lab에서 만든 상용 언어였다가, 이를 Ross Ihaka와 Robert Gentleman이라는 두 명의 뉴질랜드 교수가 뉴질랜드 오클랜드 대학에서 통계학 수업 시간에 이용할 언어로 다시 implement한 버전입니다. Implement라는 말이 이상하게 들릴 수도 있는데, 내부가 어떻게 작동하는지와는 상관 없이 같은 문법으로 작동할 수 있도록 만들었다고 생각하면 됩니다. 즉, 자동차의 부속품은 완전히 다르지만, 운전하는 방식은 완전하게 같은 두 대의 자동차를 생각하면 되겠습니다. 내부 작동 방식은 소스 코드, 이용자의 운전 방식은 implemetation이라고 간단히 생각하면 되겠습니다.

이 두 교수는 S와는 달리 이 내부가 어떻게 작동하는지 그 설계까지 공개해 버렸습니다. 이것을 보통 컴퓨터 공학자들은 '오픈소스로 풀었다'고 표현합니다. 더 나아가 이 설계를 조금 변경해서 자기만의 R을 만들거나 그것을 파는 것도 이론적으로 가능합니다.

R이 '통계학자들의 보편 언어'라고 하는 데에는 여러가지 뜻이 숨어있습니다. 먼저 통계학자들이 만든 언어라는 것은 중요합니다. 통계학자들은 수학을 그들의 언어로 사용하고 이는 중고등 교육을 받은 우리의 직관과 유사하기 때문에, 통계학자들의 머리에서 나온 이 언어는 우리의 직관에서 크게 벗어나지 않습니다. 당장, 우리가 계산기 두드리듯 식을 넣고 엔터를 치면 동작합니다.

두번쨰로 '보편언어'라는 말도 중요합니다. 어지간한 것은 다 된다고 봐도 무방합니다.

설치 방법은 뒤로 돌리자!

여기서는 R과 Rstudio를 설명하고 기본적인 용어법, 개념을 설명합니다. 다소 지루할 수 있는 내용이지만,꼭 알아야 하니 정독해 주세요!

R은 설치도 쉽고, 간단한 이용환경을 가지고 있습니다. 프로그래밍에서 이는 통합개발환경(IDE)라고 하는데, 이는 Posit<https://posit.co/>이라는 회사가 개발 및 배포하고 있습니다.

*R과 Rstudio의 관계에 대한 그림*

## R의 역사와 이용.

## R 설치

이렇게 하면 설치가 완료됩니다.

## Rstudio 설치

## Rstudio 환경 설명

## 프로그래밍 언어의 작동과 R환경

### 변수, 함수

R의 작동 방식을 이해하기 위해서는 다음과 같은 것들을 알아야 합니다.

먼저 컴퓨터가 작동하는 방식에 대해서 간단하게만 알아봅시다. 컴퓨터에 데이터를 저장되는 곳은 크게 세 군데가 있습니다.

연산장치(CPU, GPU) - 메모리 - 저장장치(HDD, SSD)

이는 '악마의 두뇌'를 가졌다고 일컬어지기도 하는 저 유명한 수학자 존 폰 노이만(John von Neumann; 1903-1957)이 고안해 낸 컴퓨터의 구조입니다. 여기에 대해 알고 있는 것은 앞으로 불필요한 에러를 피하는데 큰 도움이 됩니다.

아직 소개하지 않았지만, 여러분이 사용할 데이터들은 HDD, SSD와 같은 저장 장치에 살고 있습니다. 파일을 저장한다는 행위는 여러분들도 익숙하실 것이라고 믿습니다. 여러분들이 데이터를 이용해서 어떤 계산을 하고 싶다면, 그 계산은 '연산장치'에서 일어납니다. CPU도 아마 많이 들어보셨을테고, 최근 인공신경망(ANN)이나, 암호화폐 채굴이 CPU 대신 GPU라는 연산장치 위에서 돌아간다는 이야기도 들어보셨을 것입니다. CPU건, GPU건, 컴퓨팅이라는 것은 결국 그들이 어떤 계산을 해 주기를 바라는 것이지요.

-   메모리 위에 쓰여진 값은 휘발한다 (전원이 꺼지면 없어진다)
-   메모리 위에 쓰여진 값은 이름이 없으면 없는 것이나 다름 없다

문제는 저장장치에 있는 데이터를 연산장치가 바로 사용하는 것이 아니라는 것입니다. 연산장치가 계산을 하기 위해서는 중간 단계에 해당하는 메모리 위에 값이 기록되어야 합니다. 그리고 아마도 여러분들이 알고 계실 것처럼, 메모리에 기록된 데이터는 휘발합니다. 즉, 컴퓨터 전원이 꺼지면 없어지는 것이죠. 이 때문에 저장장치들이 필요합니다.

그런데, 메모리에 대해서는 그것 말고도 알아야 하는 것이 있습니다. 메모리 위에 기록된 값은 *'이름'이 없으면 존재하지 않는 것이나 다름 없다*는 사실입니다. 이게 무슨 말인지 알기 위해 다음과 같은 예를 살펴 봅시다.

```{r}
3+4
```

이러한 연산이 이루어지기 위해서는 3이라는 '값'과 4라는 '값'이 메모리에 먼저 기록되어야 합니다. 그 다음에 연산 장치가 메모리에 저장된 두 값을 더하는 '연산'을 해 준 후, 그 결과 값이 7을 메모리 위에 기록합니다. 우리는 메모리 위에 기록된 결과를 모니터를 통해 보는 셈입니다. 그런데, 문제는 3, 4, 7이라는 모든 값에 별도의 이름을 붙이지 않았다는 것이지요. 앞서 말했듯이 '이름'이 없는 값은 존재하지 않는 것이나 다름 없습니다. 따라서, 우리는 메모리에 쓰여진 이 값들을 다시 사용할 수 없습니다. 모니터에서 한 번 확인하고 날려보낸 것입니다.

이는 반대로 이야기 하면, 이름을 부여한다면, 적어도 이름을 부여하는 프로그램, 즉 우리의 경우 `R`을 켜 놓은 동안은 재사용할 수 있다는 것입니다. 위의 프로그램을 다시 써 보죠.

```{r}
a <- 3
b <- 4
c <- a + b
print(c)
```

모니터에서 확인하는 결과는 같습니다. 그러나 우리는 몇 가지 작업을 더 했는데요, 3과 4를 각각 `a`와 `b`라는 이름에 할당(assign) 했습니다. 이름을 부여한 것이지요. 또 `a`에 해당하는 값과 `b`에 해당하는 값을 더한 결과 역시 `c`라는 이름에 할당했습니다. 이제 이 값들은 이름이 있으니 `R`을 켜둔 동안은 다시 불러 사용할 수 있는 것입니다.

```{r}
a * b
```

이제 앞으로 사용할 몇 가지 용어를 정의하도록 하죠. - 값(value): 데이터 그 자체 - 변수(variable): 거기에 붙은 이름 - 할당(assign): 값을 변수로 만드는 행위. `R`에서는 `<-` 부호를 사용함. (사실은 `=`을 사용할 수도 있지만, 구분하겠습니다.)

*그림*

사람의 언어에 비유해서 설명하자면, 값과 변수는 *명사*, 또는 *목적어*에 해당합니다. 많은 경우에는 이렇게 주어진 대상에 어떤 행위를 하고 싶어하지요. 우리는 그것을 *연산*이라고 합니다. 그리고 그러한 *연산*을 문법으로 표현한 것을 *함수(function)*라고 하지요. 인간의 언어에서라면 함수는 *동사*에 해당합니다.

*그림*

우리는 위의 예에서 이미 함수를 보았습니다. `print()`가 그것입니다. 이것은 주어진 값을 콘솔에 출력하는 동작을 의미하는 것이니 *동사*라고 할 수 있습니다. 그러면 동사와 명사를 구분하듯, `R`에서 변수와 함수를 구분할 수 있을까요? 구분할 수 있습니다. 여러 방법이 있지만, 가장 간단한 방법은 문자열 뒤에 *괄호*가 있는지 보는 것입니다. 변수는 괄호가 없습니다. 하지만, 함수는 `print()`처럼 괄호가 있지요.

괄호는 왜 있는 것일까요? 괄호 안에 무언가를 써넣어야 하기 때문입니다. 즉, 함수가 표현하는 행위의 대상이 되는 *목적어*를 집어 넣어야 하기 때문이죠. 예컨대 `print(c)`에서 `c`라는 변수는 바로 그 목적어에 해당하요. 앞서 값이나 변수가 목적어의 역할을 하게 될 것이라고 했던 것을 기억할 것입니다. `print(c)`를 사람의 언어로 표현하면 다음과 같습니다.

> `c`를 콘솔에 `print()`하라.

*그림 (변수, 함수)*

이렇게 값이나 변수가 함수가 하는 연산의 대상이 되면, 즉, 함수의 괄호 안에 들어가면, 이를 입력값(input), 또는 인수(argument)라고 합니다. 입력값을 받았으니 함수는 연산의 결과로 출력값(output)을 내어놓겠지요. 사실 더 정확한 표현은 다음과 같습니다.

```{r}
print(x=c)
```

여기서 `x`는 `print()`라는 함수의 매개변수(parameter), `c`는 그 매개변수에 집어넣은 인수, 또는 입력값입니다. 매개변수는 `print()`라는 함수가 그 내부에서 사용하는 변수입니다. `print()`라는 함수는 내부에서 `x`라는 변수를 이용해 행위를 하지, `c`라는 함수 밖에 존재하는 변수에 대해서는 알지 못합니다. 그런데 `x=c`라고 하는 순간, 이용자는 함수에게 "네가 이용할 `x`가 바로 바로 `c`라는 변수에 들어있는 값이야"라고 연결해 주는 것입니다.

*그림 (x=c)*

그러면 `print()`는 자신이 이용하는 `x`라는 그릇에 `c`에 이미 연결되어 있는 값을 담고 그것을 출력하는 행위를 하게 됩니다.

그런데 왜 첫번째 예에서는 `x=`을 생략하고 `print(c)`라고 했는데도 작동했을까요? 그것은 `print()` 함수 자체가 첫번째로 입력한 숫자를 `x`에 대응하는 인수로 자동으로 인식하도록 프로그램 되어 있기 때문입니다. 무언가를 출력하라고 하는 명령은 수없이 사용하게 될텐대, 매번 매개변수를 반복행 하면 너무 귀찮겠지요.

그런데, 모든 함수가 인수를 필요로 하는 것은 아닙니다. 자연언어에서 동사 역시 자동사와 타동사로 구분되는 것과 같은 이치입니다. 예컨대 다음과 같은 함수는 인수 없이 실행 됩니다.

```{r eval=FALSE}
getwd()
```

`getwd()`라는 함수가 working directory 즉, 현재 `R`이 작업을 하고 있는 컴퓨터의 경로를 표시하는 동작을 의미하니, 인수가 따로 필요하지는 않겠지요. 어떤 경우에는 함수가 인수를 필요로 하지만 (즉, 타동사 이지만), 인수를 쓰지 않아도 작동하는 경우가 있습니다. 그런 경우에는 함수가 자신이 필요로 하는 인수에 대해 디폴트 값을 가지고 있는 경우 입니다. 즉, 사용자가 아무 인수도 주지 않으면 자동으로 인수로 가정하는 값이 있는 경우도 있다는 것입니다. 우리가 "밥 먹어"하는 대신 상대방이 알아들을만 한 상황에서는 "먹어"라고 하는 것과 비슷한 이치입니다.

`getwd()`라는 함수가 working directory 즉, 현재 `R`이 작업을 하고 있는 컴퓨터의 경로를 표시하는 동작을 의미하니, 인수가 따로 필요하지는 않겠지요. 어떤 경우에는 함수가 인수를 필요로 하지만 (즉, 타동사 이지만), 인수를 쓰지 않아도 작동하는 경우가 있습니다. 그런 경우에는 함수가 자신이 필요로 하는 인수에 대해 디폴트 값을 가지고 있는 경우 입니다. 즉, 사용자가 아무 인수도 주지 않으면 자동으로 인수로 가정하는 값이 있는 경우도 있다는 것입니다. 우리가 "밥 먹어"하는 대신 상대방이 알아들을만 한 상황에서는 "먹어"라고 하는 것과 비슷한 이치입니다.

### 경로

앞서 작업폴더(working directory) 이야기를 했는데요, 이것은 무슨 의미일까요? 작업폴더는 현재 `R`이 자신이 위치하고 있다고 생각하는 저장장치 안의 폴더를 의미합니다. 보통은 지금 작성하고 있는 코드가 저장되어 있는 곳이 작업폴더가 되지만, 이는 경우에 따라 다릅니다. 그래서 앞에서처럼 `getwd()`를 이용해 현재 작업 폴더가 어디인지 확인하는 것이지요.

작업폴더가 중요한 이유는, 저장장치로부터 `R`이 데이터를 불러올 때, 특별한 이야기가 없으면 작업폴더로부터 불러와야 한다고 생각하기 때문입니다. 하지만, `R`이 현재 작업폴더로 이용하고 있는 장소와 이용자가 작업폴더라고 믿고 있는 장소 사이에 차이가 있는 경우가 종종 있습니다. 프로그래밍을 처음 해 보시는 분들이 처음에 제일 많이 겪는 에러의 원인입니다. 만약 이런 차이가 발생한다면, 해법은 세 가지가 있습니다. 첫째, `R`에게 작업폴더를 바꿀 것을 지시하면 됩니다.

```{r eval=FALSE}
setwd()
```

둘째, 불러올 데이터가 저장되어 있는 곳을 자세하게 알려주면 됩니다. 나중에 더 자세히 설명하겠지만, 다음과 같은 명령어를 볼까요?

```{r eval=FALSE}
read.csv("")
```

이는 저 파일(csv라는 확장자를 처음 보신 분들은 나중에 배우게 될테니, 일단 엑셀 파일보다 간단한 형태의 테이블 데이터 파일이라고 생각해 주세요)이 있을 경우에 파일을 불러들여서 콘솔에 출력할 것입니다 (quiz: 그렇다면 이 데이터는 우리가 앞으로 분석에 사용할 수 있는 것일까요? 아까 이름과 메모리에 대해 이야기 했던 것을 떠올려 보세요).

하지만, 해당 작업폴더에 저장되어있지 않은 데이터 파일을 불러오려고 하면, `R`은 에러를 뱉어낼 것입니다.

```{r eval=FALSE}
read.csv("")
```

이 때, 이렇게 써 보세요.

```{r eval=FALSE}
read.csv("/")
```

이것이 작동한 이유는 현재 작업폴더 아래에 있는 폴더 안에 파일이 저장되어 있기 때문입니다. 이렇게 파일로 가는 길을 *경로(path)*라고 표현하고, 특히 위의 예에서처럼 현재 작업폴더를 기준으로 경로를 설정해 주는 것을 *상대경로*라고 표현합니다. 상대경로가 있으면, *절대경로*가 있겠지요? 다음과 같은 경우를 절대경로라고 합니다.

```{r eval=FALSE}
read.csv("C:/")
```

즉, 가장 높은 폴더, 흔히 루트 디렉토리라고 부르는 장소에서부터 원하는 폴더까지 이동하는 경로를 완전히 알려주는 방식이지요.

사실 가장 권장하는 방식은 세번째 방식입니다. *프로젝트*라고 부르는 이 방식은 `R`의 기능을 활용하는 것이라기 보다는 `Rstudio`의 기능을 활용한 방식인데요, 가장 에러를 효과적으로 최소화하는 방식이라고 할 수 있습니다.

### 프로젝트

## 그 외 권장사항

프로젝트 말고도 앞으로의 학습을 위해 지키면 좋을 권장사항들이 있습니다. \### 한글 설정 `R`은 다른 많은 프로그래밍 언어들과 마찬가지로 영어권에서 개발되고 오랫동안 사용되어 왔기 때문에, 한글을 포함한 데이터를 다룰 때 자잘한 문제들을 발생시키게 됩니다. 앞서 프로젝트를 이용해서 제어하기로 한 경로 문제만큼이나 초보자에게 많은 에러를 안겨주는 이유 중 하나가 바로 이 언어의 문제 입니다. 이는 정확한 표현으로는 *인코딩* 문제라고 하는데, 인코딩은 사람이 읽을 수 있는 자연 언어를 컴퓨터가 이해하는 유일한 정보인 0,1로 이루어진 이진수로 바꾸는 과정을 의미합니다. 문제는 이러한 *인코딩* 방식이 무수히 많다는 것입니다. 예컨대 예전에 주로 사용하던 인코딩 방식은 알파벳 이외의 문자를 이진수로 바꾸는 룰을 포함하지 않고 있기도 했습니다. 여기서 발생하는 문제를 최소화하기 위해 다음과 같은 설정을 해 줄 것을 권합니다.

```{r}
Sys.setlocale("LC_ALL", "Korean")
```

이렇게 하면 `R`의 언어 설정이 바뀌면서 한글을 올바르게 출력하게 됩니다. 덤으로 에러 메시지도 한글로 바뀌지요. 그런데 에러 메시지가 한글로 나오는 것은 장점이 되기도, 단점이 되기도 합니다. 왜냐하면, 여러분이 이해할 수 없는 에러가 발생하면, 인터넷에서 해결책을 검색해야 하는데, 영어로 된 정보의 질이 압도적으로 좋기 때문입니다. 영어 에러 메시지를 이용해 해법을 검색하면 영어 이용자가 작성한 답변을 검색할 수 있지만, 한글 에러 메시지를 이용해 검색하게 되면 이용할 수 있는 정보의 풀이 크게 줄어들게 됩니다. 이 경우, 언어 세팅을 다시 영어로 돌려놓고 싶을 수 있겠지요. 그럴 때는 다음과 같은 명령어를 실행시킵니다.

```{r}
Sys.setlocale("LC_ALL", "C")
```

또 하나 주의해야 할 것은, 이 혼경설정은 여러분이 코딩을 마치고 `Rstudio`를 끄는 순간 날아가버린다는 것입니다. 따라서 한글 데이터를 다룰 때에는 코딩을 시작하기 전에 이 세팅을 먼저 해 주는 것이 좋습니다.

### 숫자 표시 설정

`R`은 애초에 우리와 같은 문과생들이 이용하라고 만든 언어가 아닙니다. 그래서 우리의 머리로써는 이해하기 힘든 초기 설정을 가지고 있는 경우가 종종 있는데요, 그 중 대표적인 것이 숫자 표시 설정입니다. 많은 분들이 아시겠지만, 공학에서는 숫자를 *과학적 기수법* 이라는 것을 통해 표시하는 경우가 많습니다.

*그림*

이는 공학에서 너무 작거나, 너무 큰 수를 다루어야 하는 경우가 많다보니, 숫자를 길게 쓰는 수고를 줄이고자 도입된 것입니다. 그러나 이러한 표기법에 익숙한 우리나, 우리가 작성한 기사를 읽을 독자 중 다수는 이러한 표기법에 익숙하지 못할 것입니다. 따라서 다음과 같은 명령어를 실행시켜 숫자 표시 설정을 바꾸어주는 것이 좋습니다.

```{r}
options(scipen=999)
```

사실 위의 명령어에 들어가는 숫자는 999자리 이상이 아니면 과학적 기수법을 사용하지 말라는 것이니꼭 999이어야 하는 것은 아닙니다. 충분히 큰 수이면 됩니다. 이 설정 역시 `Rstudio`를 끄는 순간 메모리에서 지워지니, 코딩을 시작하실 때마다 다시 설정해주시는 것이 좋습니다.

### 에러 메시지 읽기

사실 에러 메시지는 매우 중요한 정보들을 담고 있습니다. 에러 메시지를 얼마나 정성들여 읽느냐에 따라 코딩 실력이 느는 속도가 천차만별로 차이가 나게 되니, 꼭 에러 메시지를 소중하게 읽기를 권합니다.

## 마크다운과 마크업

사실 "마크다운"이라는 용어는 일종의 말장난입니다. 원래는 "마크업(markup)"이라는 용어가 먼저 있었지요. 마크업이라는 것은 일반 텍스트에 "여러 표시를 해서(mark up)", 텍스트에 여러 효과와 형식을 부여하는 문법을 의미합니다. 가장 대표적인 예가 바로 HTML 이죠.

```         
<!DOCTYPE html>
<html>
<body>

<h1> 이것은 제목 입니다</h1>

<p> 이것은 문단 입니다 </p>

</body>
</html>
```

여기에 쓰여진 "이것은 제목 입니다", "이것은 문단 입니다" 등의 텍스트들은 바로 우리가 전달하고 싶은 텍스트 정보 입니다. 하지만 효율적으로 이를 독자들에게 전달하기 위해서는 약간의 양식이 있으면 좋겠죠. 따라서 제목은 제목처럼 보이게 문단은 문단처럼 보이게 하는 양식 정보를 전달하는 것이 '

<h1>

</h1>

','

<p>

</p>

' 같은 HTML 문법입니다. 구글 크롬, 마이크로소프트 엣지 같은 웹브라우저는 이러한 양식을 이해해서 이용자에게 텍스트를 그대로 전달하는 것이 아니라, 양식이 부여된 텍스트 시각화해서(이를 "Render"라고 합니다) 보여주는 역할을 합니다.

사실 이렇게 텍스트에다 여러 양식정보를 부가하는(즉, 마크업하는) 문법은 HTML말고도 여러개가 있습니다. 이들을 통틀어 '마크업 언어'라고 하지요. 그런데, 위의 HTML 문서에서 알 수 있듯이, 단 두문장을 전달하는 데에도 사용해야 할 문법이 꽤나 복잡하고 많습니다. 이 때문에 개발자들은 텍스트에 양식을 부과하되, 사람이 직관적으로 이해할 수 있는 좀 간단한 문법이 없을까? 라는 생각을 하게되었습니다. 그 결과물이 바로 '마크다운'이지요, 즉, 마크'업'이 너무 복잡해서 간단하게 만든 새로운 마크업 문법이 마크'다운'이라는 것입니다.

이제 간단한 마크다운 문법을 알면 이용자는 HTML 같이 복잡한 마크업 문법을 몰라도 웹페이지를 간단하게 만들 수 있습니다. Rstudio가 내장하고 있는 프로그램이 마크다운 문서를 HTML로 다시 재번역해 주거든요(그것이 여러분이 `Rstudio`에서 이용하는 `Render` 버튼의 의미입니다). 여러분들이 매일 이용하는 웹브라우저는 이렇게 번역된 HTML을 이해할 수 있으니 여러분은 뉴스 작성을 위해 HTML을 따로 공부할 필요가 없습니다.

**마크업 -\> pandoc -\> HTML -\> 웹브라우저**

명심하세요! 여러분들은 이 책을 통해 연습을 하는 동안 항상 `qmd` 파일을 하나 만들어 마크다운 문법을 이요해 코드와 텍스트를 동시에 작성하고 이를 HTML로 렌더하는 작업을 반복할 것입니다. 그 외에도 `R`을 사용하는 여러 방법이 있지만, 일단 가장 쉽고 기사 작성을 위해 유용한 이 방법을 반복해서 사용하세요!
