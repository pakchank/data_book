# R과 Rstudio 인스톨

여기서는 R과 Rstudio를 설명하고 기본적인 용어법, 개념을 설명합니다. 다소 지루할 수 있는 내용이지만,꼭 알아야 하니 정독해 주세요!

R은 설치도 쉽고, 간단한 이용환경을 가지고 있습니다. 프로그래밍에서 이는 통합개발환경(IDE)라고 하는데, 이는 Posit<https://posit.co/>이라는 회사가 개발 및 배포하고 있습니다.

*R과 Rstudio의 관계에 대한 그림*

## R의 역사와 이용.

R은 통계학자들이 만든 언어입니다. 원래는 S라는 유명한 Bell Lab에서 만든 상용 언어였다가, 이를 Ross Ihaka와 Robert Gentleman이라는 두 명의 뉴질랜드 교수가 뉴질랜드 오클랜드 대학에서 통계학 수업 시간에 이용할 언어로 다시 implement한 버전입니다. Implement라는 말이 이상하게 들릴 수도 있는데, 내부가 어떻게 작동하는지와는 상관 없이 같은 문법으로 작동할 수 있도록 만들었다고 생각하면 됩니다. 즉, 자동차의 부속품은 완전히 다르지만, 운전하는 방식은 완전하게 같은 두 대의 자동차를 생각하면 되겠습니다. 내부 작동 방식은 소스 코드, 이용자의 운전 방식은 implemetation이라고 간단히 생각하면 되겠습니다.

이 두 교수는 S와는 달리 이 내부가 어떻게 작동하는지 그 설계까지 공개해 버렸습니다. 이것을 보통 컴퓨터 공학자들은 '오픈소스로 풀었다'고 표현합니다. 더 나아가 이 설계를 조금 변경해서 자기만의 R을 만들거나 그것을 파는 것도 이론적으로 가능합니다.

R이 '통계학자들의 보편 언어'라고 하는 데에는 여러가지 뜻이 숨어있습니다. 먼저 통계학자들이 만든 언어라는 것은 중요합니다. 통계학자들은 수학을 그들의 언어로 사용하고 이는 중고등 교육을 받은 우리의 직관과 유사하기 때문에, 통계학자들의 머리에서 나온 이 언어는 우리의 직관에서 크게 벗어나지 않습니다. 당장, 우리가 계산기 두드리듯 식을 넣고 엔터를 치면 동작합니다.

두번쨰로 '보편언어'라는 말도 중요합니다. 어지간한 것은 다 된다고 봐도 무방합니다.

## R 설치

이렇게 하면 설치가 완료됩니다.

## Rstudio 설치

## Rstudio 환경 설명

Text, Qmd, 콘솔

## 변수, 함수

*서영씨에게 그림을 좀 그려달라고 해야겠다.* *명사 동사 값 화살표 등등에 대한 그림.*

R의 작동 방식을 이해하기 위해서는 다음과 같은 것들을 알아야 합니다.

먼저 컴퓨터가 작동하는 방식에 대해서 간단하게만 알아봅시다. 컴퓨터에 데이터를 저장되는 곳은 크게 세 군데가 있습니다.

연산장치(CPU, GPU) - 메모리 - 저장장치(HDD, SSD)

이는 '악마의 두뇌'를 가졌다고 일컬어지기도 하는 저 유명한 수학자 존 폰 노이만(John von Neumann; 1903-1957)이 고안해 낸 컴퓨터의 구조입니다. 여기에 대해 알고 있는 것은 앞으로 불필요한 에러를 피하는데 큰 도움이 됩니다.

아직 소개하지 않았지만, 여러분이 사용할 데이터들은 HDD, SSD와 같은 저장 장치에 살고 있습니다. 파일을 저장한다는 행위는 여러분들도 익숙하실 것이라고 믿습니다. 여러분들이 데이터를 이용해서 어떤 계산을 하고 싶다면, 그 계산은 '연산장치'에서 일어납니다. CPU도 아마 많이 들어보셨을테고, 최근 인공신경망(ANN)이나, 암호화폐 채굴이 CPU 대신 GPU라는 연산장치 위에서 돌아간다는 이야기도 들어보셨을 것입니다. CPU건, GPU건, 컴퓨팅이라는 것은 결국 그들이 어떤 계산을 해 주기를 바라는 것이지요.

-   메모리 위에 쓰여진 값은 휘발한다 (전원이 꺼지면 없어진다)
-   메모리 위에 쓰여진 값은 이름이 없으면 없는 것이나 다름 없다

문제는 저장장치에 있는 데이터를 연산장치가 바로 사용하는 것이 아니라는 것입니다. 연산장치가 계산을 하기 위해서는 중간 단계에 해당하는 메모리 위에 값이 기록되어야 합니다. 그리고 아마도 여러분들이 알고 계실 것처럼, 메모리에 기록된 데이터는 휘발합니다. 즉, 컴퓨터 전원이 꺼지면 없어지는 것이죠. 이 때문에 저장장치들이 필요합니다.

그런데, 메모리에 대해서는 그것 말고도 알아야 하는 것이 있습니다. 메모리 위에 기록된 값은 *'이름'이 없으면 존재하지 않는 것이나 다름 없다*는 사실입니다. 이게 무슨 말인지 알기 위해 다음과 같은 예를 살펴 봅시다.

```{r}
3+4
```

이러한 연산이 이루어지기 위해서는 3이라는 '값'과 4라는 '값'이 메모리에 먼저 기록되어야 합니다. 그 다음에 연산 장치가 메모리에 저장된 두 값을 더하는 '연산'을 해 준 후, 그 결과 값이 7을 메모리 위에 기록합니다. 우리는 메모리 위에 기록된 결과를 모니터를 통해 보는 셈입니다. 그런데, 문제는 3, 4, 7이라는 모든 값에 별도의 이름을 붙이지 않았다는 것이지요. 앞서 말했듯이 '이름'이 없는 값은 존재하지 않는 것이나 다름 없습니다. 따라서, 우리는 메모리에 쓰여진 이 값들을 다시 사용할 수 없습니다. 모니터에서 한 번 확인하고 날려보낸 것입니다.

이는 반대로 이야기 하면, 이름을 부여한다면, 적어도 이름을 부여하는 프로그램, 즉 우리의 경우 `R`을 켜 놓은 동안은 재사용할 수 있다는 것입니다. 위의 프로그램을 다시 써 보죠.

```{r}
a <- 3
b <- 4
c <- a + b
print(c)
```

모니터에서 확인하는 결과는 같습니다. 그러나 우리는 몇 가지 작업을 더 했는데요, 3과 4를 각각 `a`와 `b`라는 이름에 할당(assign) 했습니다. 이름을 부여한 것이지요. 또 `a`에 해당하는 값과 `b`에 해당하는 값을 더한 결과 역시 `c`라는 이름에 할당했습니다. 이제 이 값들은 이름이 있으니 `R`을 켜둔 동안은 다시 불러 사용할 수 있는 것입니다.

```{r}
a * b
```

이제 앞으로 사용할 몇 가지 용어를 정의하도록 하죠. - 값(value): 데이터 그 자체 - 변수(variable): 거기에 붙은 이름 - 할당(assign): 값을 변수로 만드는 행위. `R`에서는 `<-` 부호를 사용함. (사실은 `=`을 사용할 수도 있지만, 구분하겠습니다.)

*그림*

사람의 언어에 비유해서 설명하자면, 값과 변수는 *명사*, 또는 *목적어*에 해당합니다. 많은 경우에는 이렇게 주어진 대상에 어떤 행위를 하고 싶어하지요. 우리는 그것을 *연산*이라고 합니다. 그리고 그러한 *연산*을 문법으로 표현한 것을 *함수(function)*라고 하지요. 인간의 언어에서라면 함수는 *동사*에 해당합니다.

*그림*

우리는 위의 예에서 이미 함수를 보았습니다. `print()`가 그것입니다. 이것은 주어진 값을 콘솔에 출력하는 동작을 의미하는 것이니 *동사*라고 할 수 있습니다. 그러면 동사와 명사를 구분하듯, `R`에서 변수와 함수를 구분할 수 있을까요? 구분할 수 있습니다. 여러 방법이 있지만, 가장 간단한 방법은 문자열 뒤에 *괄호*가 있는지 보는 것입니다. 변수는 괄호가 없습니다. 하지만, 함수는 `print()`처럼 괄호가 있지요.

괄호는 왜 있는 것일까요? 괄호 안에 무언가를 써넣어야 하기 때문입니다. 즉, 함수가 표현하는 행위의 대상이 되는 *목적어*를 집어 넣어야 하기 때문이죠. 예컨대 `print(c)`에서 `c`라는 변수는 바로 그 목적어에 해당하요. 앞서 값이나 변수가 목적어의 역할을 하게 될 것이라고 했던 것을 기억할 것입니다. `print(c)`를 사람의 언어로 표현하면 다음과 같습니다.

> `c`를 콘솔에 `print()`하라.

*그림 (변수, 함수)*

이렇게 값이나 변수가 함수가 하는 연산의 대상이 되면, 즉, 함수의 괄호 안에 들어가면, 이를 입력값(input), 또는 인수(argument)라고 합니다. 입력값을 받았으니 함수는 연산의 결과로 출력값(output)을 내어놓겠지요. 사실 더 정확한 표현은 다음과 같습니다.

```{r}
print(x=c)
```

여기서 `x`는 `print()`라는 함수의 매개변수(parameter), `c`는 그 매개변수에 집어넣은 인수, 또는 입력값입니다. 매개변수는 `print()`라는 함수가 그 내부에서 사용하는 변수입니다. `print()`라는 함수는 내부에서 `x`라는 변수를 이용해 행위를 하지, `c`라는 함수 밖에 존재하는 변수에 대해서는 알지 못합니다. 그런데 `x=c`라고 하는 순간, 이용자는 함수에게 "네가 이용할 `x`가 바로 바로 `c`라는 변수에 들어있는 값이야"라고 연결해 주는 것입니다.

*그림 (x=c)*

그러면 `print()`는 자신이 이용하는 `x`라는 그릇에 `c`에 이미 연결되어 있는 값을 담고 그것을 출력하는 행위를 하게 됩니다.

그런데 왜 첫번째 예에서는 `x=`을 생략하고 `print(c)`라고 했는데도 작동했을까요? 그것은 `print()` 함수 자체가 첫번째로 입력한 숫자를 `x`에 대응하는 인수로 자동으로 인식하도록 프로그램 되어 있기 때문입니다. 무언가를 출력하라고 하는 명령은 수없이 사용하게 될텐대, 매번 매개변수를 반복행 하면 너무 귀찮겠지요.

그런데, 모든 함수가 인수를 필요로 하는 것은 아닙니다. 자연언어에서 동사 역시 자동사와 타동사로 구분되는 것과 같은 이치입니다. 예컨대 다음과 같은 함수는 인수 없이 실행 됩니다.

```{r eval=FALSE}
getwd()
```

`getwd()`라는 함수가 working directory 즉, 현재 `R`이 작업을 하고 있는 컴퓨터의 경로를 표시하는 동작을 의미하니, 인수가 따로 필요하지는 않겠지요. 어떤 경우에는 함수가 인수를 필요로 하지만 (즉, 타동사 이지만), 인수를 쓰지 않아도 작동하는 경우가 있습니다. 그런 경우에는 함수가 자신이 필요로 하는 인수에 대해 디폴트 값을 가지고 있는 경우 입니다. 즉, 사용자가 아무 인수도 주지 않으면 자동으로 인수로 가정하는 값이 있는 경우도 있다는 것입니다. 우리가 "밥 먹어"하는 대신 상대방이 알아들을만 한 상황에서는 "먹어"라고 하는 것과 비슷한 이치입니다.

## 경로

앞서 작업폴더(working directory) 이야기를 했는데요, 이것은 무슨 의미일까요? 작업폴더는 현재 `R`이 자신이 위치하고 있다고 생각하는 저장장치 안의 폴더를 의미합니다. 보통은 지금 작성하고 있는 코드가 저장되어 있는 곳이 작업폴더가 되지만, 이는 경우에 따라 다릅니다. 그래서 앞에서처럼 `getwd()`를 이용해 현재 작업 폴더가 어디인지 확인하는 것이지요.

작업폴더가 중요한 이유는, 저장장치로부터 `R`이 데이터를 불러올 때, 특별한 이야기가 없으면 작업폴더로부터 불러와야 한다고 생각하기 때문입니다. 하지만, `R`이 현재 작업폴더로 이용하고 있는 장소와 이용자가 작업폴더라고 믿고 있는 장소 사이에 차이가 있는 경우가 종종 있습니다. 프로그래밍을 처음 해 보시는 분들이 처음에 제일 많이 겪는 에러의 원인입니다. 만약 이런 차이가 발생한다면, 해법은 세 가지가 있습니다. 첫째, `R`에게 작업폴더를 바꿀 것을 지시하면 됩니다.

```{r eval=FALSE}
setwd()
```

둘째, 불러올 데이터가 저장되어 있는 곳을 자세하게 알려주면 됩니다. 나중에 더 자세히 설명하겠지만, 다음과 같은 명령어를 볼까요?

```{r eval=FALSE}
read.csv("")
```

이는 저 파일(csv라는 확장자를 처음 보신 분들은 나중에 배우게 될테니, 일단 엑셀 파일보다 간단한 형태의 테이블 데이터 파일이라고 생각해 주세요)이 있을 경우에 파일을 불러들여서 콘솔에 출력할 것입니다 (quiz: 그렇다면 이 데이터는 우리가 앞으로 분석에 사용할 수 있는 것일까요? 아까 이름과 메모리에 대해 이야기 했던 것을 떠올려 보세요).

하지만, 해당 작업폴더에 저장되어있지 않은 데이터 파일을 불러오려고 하면, `R`은 에러를 뱉어낼 것입니다.

```{r eval=FALSE}
read.csv("")
```

이 때, 이렇게 써 보세요.

```{r eval=FALSE}
read.csv("/")
```

이것이 작동한 이유는 현재 작업폴더 아래에 있는 폴더 안에 파일이 저장되어 있기 때문입니다. 이렇게 파일로 가는 길을 *경로(path)*라고 표현하고, 특히 위의 예에서처럼 현재 작업폴더를 기준으로 경로를 설정해 주는 것을 *상대경로*라고 표현합니다. 상대경로가 있으면, *절대경로*가 있겠지요? 다음과 같은 경우를 절대경로라고 합니다.

```{r eval=FALSE}
read.csv("C:/")
```

즉, 가장 높은 폴더, 흔히 루트 디렉토리라고 부르는 장소에서부터 원하는 폴더까지 이동하는 경로를 완전히 알려주는 방식이지요.

사실 가장 권장하는 방식은 세번째 방식입니다. *프로젝트*라고 부르는 이 방식은 `R`의 기능을 활용하는 것이라기 보다는 `Rstudio`의 기능을 활용한 방식인데요, 가장 에러를 효과적으로 최소화하는 방식이라고 할 수 있습니다.

## 프로젝트

*Rstudio*에서 *프로젝트*라고 부르는 것의 개념은 정말 단순합니다. 프로젝트는 특정한 작업을 할 때는 항상 사용하기로 미리 정해놓은 폴더 그 이상도 이하도 아닙니다. 예컨대, 지금 저는 교과서를 쓰기 위해 *Rstudio*를 사용하고 있는데요, 이 교과서를 쓸 때는 `Book`이라는 프로젝트를 만들고, 해당 폴더 안에 책의 원고, 코드, 데이터 등을 모두 저장해 둡니다. 교과서를 쓰기 위해 필요한 모든 자료를 하나의 폴더 안에 모두 저장해 두고, *Rstudio*에게 "난 책을 쓸 때는 `Book` 폴더만 사용할거야", 라고 미리 말해두기만 하면, *Rstudio*에게 "나 이제부터 교과서 쓴다"라고 알려주면 *Rstudio*는 알아서 작업경로를 바꿔줍니다.

물론 저는 이 교과서를 쓸 때 말고도, 다양한 이유로 *Rstudio*를 사용합니다. 예컨대 연구를 위해 `Research`라는 프로젝트를 만들어 두었다고 해 보죠. 그러면 *Rstudio*에게 "나 이제부터 연구한다" 라고 말해주면 *Rstudio*는 `Research` 폴더로 작업 경로를 바꿔줍니다. 그러면 교과서를 쓰다가 연구를 하다가 반복한다고 하더라도 작업경로 때문에 골치아픈 에러를 겪을 일이 없어지겠지요. 여러 개의 기획 기사를 동시에 쓰는 상황이라면, 기사1, 기사2, 기사3에 대한 프로젝트를 따로 만들어 두고 해당 기사를 작성할 때는 해당 프로젝트 안에서 활동하면 헷갈릴 일이 없습니다.

이렇게만 이야기하면, 프로젝트가 큰 쓸모가 없어보이지만, 동시에 하는 작업의 종류가 늘어날 수록 경로로 인해 발생하는 에러의 빈도는 그야말로 '기하급수'적으로 늘어납니다. *Rstudio*의 기능 중에 프로젝트 보다 에러를 줄여주는 기능은 없다고 감히 단언할 수 있으니, `R`을 처음 배우는 지금부터 꼭 프로젝트를 사용하는 버릇을 들이길 바랍니다.

그러면, 프로젝트를 어떻게 만들고, 어떻게 프로젝트 사이를 이동하는지를 살펴보겠습니다.

### 새 프로젝트 만들기

새 프로젝트를 만드는 방법은 간단합니다. `Rstudio`의 `File` 메뉴를 선택해보세요. 그러면 드롭다운 메뉴에서 `New Proejct`라는 기능을 찾을 수 있습니다. 이를 누르면, 다음과 같은 화면이 등장할 것입니다.

*캡처*

여기서 프로젝트 명은 새로 만들어질 폴더의 이름이고, 경로는 그 폴더가 만들어질 상위 폴더라고 생각하시면 됩니다. 예컨대 위의 예에서, 저는 `Spring2023` 폴더 아래 `Book`이라는 새로운 폴더를 만들어 바로 그 폴더를 프로젝트 폴더로 사용하려는 것이지요.

`OK`를 누르고 나면, 몇 초에 걸쳐 프로젝터(=폴더)가 만들어집니다. 프로젝트가 폴더에 불과하다는 것을 확인하기 위해서 해당 폴더를 찾아보지요. 저는 지금 윈도우를 이용하고 있기 때문에 탐색기를 이용하겠습니다.

*캡처*

새로 폴더가 하나 만들어져 있지요? 그 안에는 `Book.Rproj`라는 파일도 자동으로 만들어져 있는데, 이 파일은 단지 이 폴더가 그냥 폴더가 아니고 `R`을 이용한 프로젝트를 수행하기 위한 폴더임을 표시하는 것입니다. 이것은 조금 있다가 서로 다른 폴더 사이를 이동할 때 이용할 것입니다. 자, 이제 우리는 이제 책을 쓰기 위해서는 이 폴더만 사용하게 될 것입니다. 새로 작성한 코드도, 사용할 데이터도 이 폴더 안에 모두 저장하는 것이지요.

### 프로젝트 바꾸기

그런데 이미 복수의 프로젝트를 가지고 있었다면, 프로젝트 사이는 어떻게 왔다갔다 할 수 있을까요? 간단합니다. 다시 `File` 메뉴를 선택해 보세요. 그러면 `Open Project`라는 기능이 있을 것입니다. 이것을 선택하면, 일반 탐색기처럼 폴더를 선택할 수 있습니다. 만약 `Research`라는 프로젝트로 이동하고 싶다고 해당 프로젝트 폴더를 찾아가면 됩니다. `Research` 프로젝트가 이미 만들어져 있었다면 해당 폴더에는 `Research.Rproj`라는 파일이 저장되어 있겠지요. 그 파일을 선택한 후, `OK`를 누르면 이제 `Rstudio`는 `Research` 프로젝트로 이동합니다. 이제 저는 연구를 하는 것입니다.

*캡처*

그런데, 사실 이렇게 복잡한 프로젝트 사이를 이동하는 경우는 많지 않습니다. 더 간단한 방법이 있거든요. 아까 이용한 `Open Project` 메뉴 아래에는 `Recent Projects`라는 메뉴도 있습니다. 그 위에 마우스 포인트를 올리면 최근에 이용한 프로젝트의 목록이 나타납니다. 그 목록 중 내가 이동하고 싶은 프로젝트를 클릭하면, 아주 간단하게 프로젝트 사이를 이동할 수 있습니다.

이제 여러분이 `Rstudio`를 켜고 작업을 하려고 할 때 처음으로 해야 할 일은 적절한 프로젝트를 이용하는 것입니다. 새로운 작업을 시작한다면? 프로젝트를 만드세요. 만약 프로젝트를 이미 만들어 놓은 작업을 계속하고 싶다면? 지금 `Rstudio`가 그 작업에 해당하는 프로젝트를 이용하고 있는지 확인하세요. 만약 그렇지 않다면 `Recent Projects`나 `Open Project`를 이용해 해당 프로젝트로 이동하면 됩니다. 항상 작업은 그 이후에 시작합니다.

## 그 외 권장사항

프로젝트 말고도 앞으로의 학습을 위해 지키면 좋을 권장사항들이 있습니다. \### 한글 설정 `R`은 다른 많은 프로그래밍 언어들과 마찬가지로 영어권에서 개발되고 오랫동안 사용되어 왔기 때문에, 한글을 포함한 데이터를 다룰 때 자잘한 문제들을 발생시키게 됩니다. 앞서 프로젝트를 이용해서 제어하기로 한 경로 문제만큼이나 초보자에게 많은 에러를 안겨주는 이유 중 하나가 바로 이 언어의 문제 입니다. 이는 정확한 표현으로는 *인코딩* 문제라고 하는데, 인코딩은 사람이 읽을 수 있는 자연 언어를 컴퓨터가 이해하는 유일한 정보인 0,1로 이루어진 이진수로 바꾸는 과정을 의미합니다. 문제는 이러한 *인코딩* 방식이 무수히 많다는 것입니다. 예컨대 예전에 주로 사용하던 인코딩 방식은 알파벳 이외의 문자를 이진수로 바꾸는 룰을 포함하지 않고 있기도 했습니다. 여기서 발생하는 문제를 최소화하기 위해 다음과 같은 설정을 해 줄 것을 권합니다.

```{r}
Sys.setlocale("LC_ALL", "Korean")
```

이렇게 하면 `R`의 언어 설정이 바뀌면서 한글을 올바르게 출력하게 됩니다. 덤으로 에러 메시지도 한글로 바뀌지요. 그런데 에러 메시지가 한글로 나오는 것은 장점이 되기도, 단점이 되기도 합니다. 왜냐하면, 여러분이 이해할 수 없는 에러가 발생하면, 인터넷에서 해결책을 검색해야 하는데, 영어로 된 정보의 질이 압도적으로 좋기 때문입니다. 영어 에러 메시지를 이용해 해법을 검색하면 영어 이용자가 작성한 답변을 검색할 수 있지만, 한글 에러 메시지를 이용해 검색하게 되면 이용할 수 있는 정보의 풀이 크게 줄어들게 됩니다. 이 경우, 언어 세팅을 다시 영어로 돌려놓고 싶을 수 있겠지요. 그럴 때는 다음과 같은 명령어를 실행시킵니다.

```{r}
Sys.setlocale("LC_ALL", "C")
```

또 하나 주의해야 할 것은, 이 혼경설정은 여러분이 코딩을 마치고 `Rstudio`를 끄는 순간 날아가버린다는 것입니다. 따라서 한글 데이터를 다룰 때에는 코딩을 시작하기 전에 이 세팅을 먼저 해 주는 것이 좋습니다.

### 숫자 표시 설정

`R`은 애초에 우리와 같은 문과생들이 이용하라고 만든 언어가 아닙니다. 그래서 우리의 머리로써는 이해하기 힘든 초기 설정을 가지고 있는 경우가 종종 있는데요, 그 중 대표적인 것이 숫자 표시 설정입니다. 많은 분들이 아시겠지만, 공학에서는 숫자를 *과학적 기수법* 이라는 것을 통해 표시하는 경우가 많습니다.

*그림*

이는 공학에서 너무 작거나, 너무 큰 수를 다루어야 하는 경우가 많다보니, 숫자를 길게 쓰는 수고를 줄이고자 도입된 것입니다. 그러나 이러한 표기법에 익숙한 우리나, 우리가 작성한 기사를 읽을 독자 중 다수는 이러한 표기법에 익숙하지 못할 것입니다. 따라서 다음과 같은 명령어를 실행시켜 숫자 표시 설정을 바꾸어주는 것이 좋습니다.

```{r}
options(scipen=999)
```

사실 위의 명령어에 들어가는 숫자는 999자리 이상이 아니면 과학적 기수법을 사용하지 말라는 것이니꼭 999이어야 하는 것은 아닙니다. 충분히 큰 수이면 됩니다. 이 설정 역시 `Rstudio`를 끄는 순간 메모리에서 지워지니, 코딩을 시작하실 때마다 다시 설정해주시는 것이 좋습니다.

### 에러 메시지 읽기

사실 에러 메시지는 매우 중요한 정보들을 담고 있습니다. 에러 메시지를 얼마나 정성들여 읽느냐에 따라 코딩 실력이 느는 속도가 천차만별로 차이가 나게 되니, 꼭 에러 메시지를 소중하게 읽기를 권합니다.
