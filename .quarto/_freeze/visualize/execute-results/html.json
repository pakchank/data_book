{
  "hash": "37b651ecd0a5cfb06caf0a1009debcfc",
  "result": {
    "markdown": "# 시각화\n\n앞선 챕터에서 연습한 그룹별 요약까지 이루어지고 나면, 시각화는 단지 요약된 결과를 시각 정보로 전달하는 것에 불과합니다.\n\n사실 `R`에는 `tidyverse` 방식의 시각화 말고도 강력한 시각화 기능이 포함되어 있는데요, `tidyverse`에 포함된 `ggplot2`라는 시각화 패키지는 그 기능이 너무 출중하여,웹 뿐 아니라 출판을 위한 시각화 자료 생성에 사실상 기본적인 `R`의 시각화 기능을 대체하는 표준 문법으로 자리잡았습니다. 심지어 `R`이 아닌 다른 언어를 쓰는 데이터 과학자들도 시각화만큼은 `ggplot2`를 사용하는 경우가 있을 정도 입니다.\n\n## `ggplot2`의 게층(layer) 개념\n\n`ggplot2`는 상당히 독특한 문법 체계를 가지고 있습니다. 일단, `ggplot2`만의 독특한 계층(layer)체계를 이해해야 합니다. `ggplot2`는 시각화를 데이터로부터 최종 시각 표현까지 도달하기 위해 순서대로 계층을 쌓는 과정으로 이해합니다. 그 계층들은 다음과 같습니다.\n\n1.  Data\n2.  Aesthetic\n3.  Geometries\n4.  Facets\n5.  Statistics\n6.  Coordinates\n7.  Theme\n\n다음 그림은 이를 표현하고 있습니다.\n\n**계층 그림**\n\n1.  Data 계층은 `ggplot2`로 시각화하고 싶은 테이블 형태의 데이터를 의미합니다. 해당 데이터에 포함된 각 컬럼은 '변수'를 나타내는데, 시각화에 대해 이야기 할 때는 데이터에 포함된 변수를 **외부변수**라고 부르겠습니다.\n\n2.  그 위에 Aesthetics 계층이 얹혀집니다. Aesthetics 계층은 Data계층에 포함된 **외부변수**와 `ggplot2`가 스스로 이해할 수 있는 **내부변수** 간의 연결을 만들어 줍니다. 그러한 내부변수들로는 다음과 같은 것들이 있습니다.\n\n    -   `x`: x축 값으로 표현하는 변수\n    -   `y`: y축 값으로 표현하는 변수\n    -   `color`: 선 색깔로 표현하는 변수\n    -   `fill`: 면적의 색깔로 표현하는 변수\n    -   `size`: 크기로 표현하는 변수\n    -   `linetype`: 선의 모양으로 표현하는 변수\n    -   `group`: 그룹을 정의하는 변수 Aestheics 계층에서 이용자는 데이터에 포함된 컬럼, 즉, 외부 변수 중 어느 것들이 이들 내부 변수에 해당할 것인지를 지정해 주어야 합니다.\n\n    *그림: 외부변수-내부변수*\n\n3.  Geometries 계층은 그래프 타입이라고 생각하면 됩니다. 선 그래프, 바 그래프, 파이 차트 등이 대표적인 그래프 타입들입니다.\n\n4.  Facets계층은 여러개의 그래프를 동시에 표현하는 것을 의미합니다. 예컨대, 한국과 미국에 대해 비교를 같은 종류의 그래프를 나란히 그려주는 것 입니다.\n\n    *그림: facets*\n\n5.  Statistics 계층은, 시각화 전에 `ggplot2`가 자체적으로 특정 계산을 해 주는 것을 의미합니다.\n\n6.  Coordinates 계층은 말 그대로 좌표계를 선택하는 것입니다. 우리가 일반적으로 알고 있는 유클리디안 좌표계 말고도, 극 좌표계와 같이 특수한 좌표계를 이용할 수도 있고, 일반 좌표계에서도 x축의 간격과 y축의 간격을 다르게 하거나, x축과 y축을 바꾸어버릴 수도 있습니다.\n\n7.  마지막으로 Theme 계층은 그 외 시각화의 미적 부분을 정의합니다.\n\n## `ggplot2` 사용해보기\n\n이제 바로 `gglot2`를 사용해 앞서 만들어낸 그룹별 요약을 바로 시각화 해 보겠습니다.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nprojects <- read_csv(\"data/projects.csv\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprojects |>\n    group_by(school_state) |>\n    summarise(avg_size = mean(total_price_excluding_optional_support),\n              count = n()) |>\n    filter(avg_size > 600) |>\n    ggplot() +\n    aes(x=school_state, y=avg_size, fill=school_state) +\n    geom_bar(stat=\"identity\") \n```\n\n::: {.cell-output-display}\n![](visualize_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n`ggplot()`으로 시작하는 코드가 나오기 전까지의 코드는 이전 챕터에서 만들어낸 그룹별 요약 + 서브세트와 정확하게 동일합니다. 즉, 앞서 만들어낸 그룹별 요약는데 이어서, `ggplot2`의 계층을 규칙대로 쌓아주기만 하면, 시각화 자료가 만들어집니다. 그러면 `ggplot2` 문법 부분을 차례대로 설명해 볼까요? 1. `ggplot()`: 이제부터 `ggplot2`를 이용해 시각화를 시작한다는 의미입니다. 이 앞의 코드를 통해 만들어 낸 그룹별 요약의 결과 역시 데이터 프레임이라고 했고, 이를 파이프를 통해 `ggplot()` 함수와 연결 시켰기 때문에, 앞서 만든 요약 결과가 `ggplot2`를 통한 시각화의 'Data' 계층에 해당한다는 것을 알 수 있습니다. 2. `aes(x=school_state, y=avg_size, fill=school_state)`: `aes()`는 Aesthetics 계층을 의미합니다. 즉, 여기서는 '내부변수'인 `x`, `y`, `fill`을 '외부변수'인 `school_state`, `avg_size`, `school_state`와 연결시키고 있는 것입니다. 물론 이들 외부 변수 이름은 Data 계층에 존재하지 않는다면 에러가 발생할 것입니다. `x`와 `fill` 모두에 `school_state`이 연결되어 있다는 것에도 주목해보세요. `x`와 `school_state`이 연결되었기 때문에, `x`축의 한 자리마다 하나의 주에 해당하는 바 그래프가 그려진 것이지만, 또, `fill`과 `school_state`도 연결되었기 때문에, 각 주는 다른 색깔의 바 그래프를 가지게 된 것입니다. 내부변수 `fill`을 사용하지 않으면 어떻게 되는지 확인하고 싶다면, `fill=school_state` 부분을 지우고 다시 실행시켜보세요. 3. `geom_bar(stat=\"identity\")`: 먼저 `geom_bar()`는 Geometries 계층으로 바 그래프를 선택했다는 것을 의미합니다. 그런데 그 안에 `stat=\"identity\"`라는 인수가 있지요? 이는 Statistics 계층에 대한 조작입니다. `geom_bar()` 함수는 우리가 아무런 지시도 하지 않으면 기본 동작으로 Data 계층에서 숫자를 센다음 이를 내부 변수 `y`로 삼으려는 계산 즉, Statistics 계층에서의 행동을 기본 값으로 가지고 있습니다. 다른 geometries 함수들은 대개 그렇지 않은데, 이는 `geom_bar()` 함수의 특성입니다. 그런데, 우리는 우리가 원하는 `y` 값으로 `avg_size`를 미리 계산해 두었지요? 따라서, `stat=\"identity\"`라는 옵션을 줌으로써 이용자가 Data 계층을 통해 공급한 외부 변수와, Aestheics 계층에서 만든 내부변수 `y`와의 연결을 \"시키는 그대로(=identity)\" 받아들이라고 명령하는 것입니다.\n\n여기까지 해서 우리는 위의 코드를 통해 Statistics 계층까지를 지정해준 것입니다. 그 외의 계층은 별도로 건드리지 않으면 기본값에 따라 시각화 표현을 만들어 줍니다.\n\n또 하나 유의해야 할 것은 `ggplot()`이라고 시각화 코드가 시작하면, 거기서부터는 `|>`라는 지금까지 써왔던 파이프 대신 `+`를 파이프로 사용한다는 것입니다. 이를 잊어버리는 것도 에러를 발생시키는 흔한 원인이 되니 유의하기 바랍니다.\n\n경우에 따라서는 막대 그래프를 세로가 아니라 가로로 그리고 싶을 때도 있습니다. 그럴 때는 어떻게 하면 좋을까요? 내부변수 `x`에 대응하는 외부변수와 `y`에 대응하는 외부변수를 바꿔지기만 하면 됩니다. 즉, Aesthetics 계층만 살짝 수정해부면 되는 것이지요. 이제 왜 `ggplot2`의 계층 구조가 편리한 것인지 조금 감이 오실 것입니다. 다음 코드가 앞의 코드와 다른 점을 잘 찾아보세요.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprojects |>\n    group_by(school_state) |>\n    summarise(avg_size = mean(total_price_excluding_optional_support),\n              count = n()) |>\n    filter(avg_size > 600) |>\n    ggplot() +\n    aes(x=avg_size, y=school_state, fill=school_state) +\n    geom_bar(stat=\"identity\") \n```\n\n::: {.cell-output-display}\n![](visualize_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n\n## 선그래프와 시간 데이터의 표현\n이번에는 선 그래프를 그려보도록 하겠습니다. 선 그래프를 그리기 위해서는 Geometries 계층만 선그래프에 해당하는 것으로 바꿔주면 됩니다. `geom_bar()`를 `geom_line()`으로 대체해주는 것이지요. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nprojects |>\n    group_by(school_state) |>\n    summarise(avg_size = mean(total_price_excluding_optional_support),\n              count = n()) |>\n    filter(avg_size > 600) |>\n    ggplot() +\n    aes(x=school_state, y=avg_size) +\n    geom_line(aes(group=1)) + \n    geom_point()\n```\n\n::: {.cell-output-display}\n![](visualize_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n이 그래프 역시 맨 처음의 막대 그래프와 거의 아무런 차이가 없습니다. 단, Geometries를 변경하기 위해 `geom_bar()` 대신 `geom_line()`을 사용해 주었지요. 그리고, `geom_line()` 안에도 Aesthetics, 즉, `aes()` 함수가 있습니다. 이 역시 내부 변수와 외부 변수를 연결하는 역할을 합니다. `group` 역시 `ggplot2`가 사용하는 내부변수라고 위에서 설명했지요? 그런데, 왜 `geom_line()` 안에 있을까요? 해당 연결은 그래프 전체를 그릴 때가 아니라, 선을 그릴 때만 유효했으면 하기 때문입니다. '선을 그릴 때만' 이라니, 다른 것도 그린다는 이야기인가요? 그렇습니다. 위의 코드에서 `geom_line()` 뒤에 바로 `geom_point()`를 덧붙였지요? 이렇게 여러게의 Geometries 계층을 덧붙일 수 있다는 것을 잘 알아두세요! 선 뿐만 아니라 점도 함께 그린 것입니다(만약 이해가 잘 안 된다면, `+ geom_point()` 부분만 지우고 실행시켜보세요).  그런데, 위의 코드는 (선을 그릴 때가 아니라) 점을 그릴 때에는 `group`이라는 내부 변수에 무언가를 연결한 것이 유효하지 않다는 것을 의미합니다.\n\n그런데 `group=1`은 무엇을 의미하는 것일까요? 사실 여기에서 설명하기엔 조금 복잡한 세부사항이 숨어있지만, '그래프에 존재하는 모든 점이 하나의 그룹이라고 생각해라'라는 것을 의미한다고 일단 이해하시면 좋겠습니다. `geom_line()`은 '선을 그린다'는 행위만을 알고 있을 뿐이지, (많은 경우) 어떤 점들을 이어서 선을 그어야 하는지는 모르거든요. 그래서 여기서는 모든 점을 다 이어서 선을 그리라는 의미로 `group=1`이라고 한 것입니다.\n\n또 하나 첫번째 코드와의 차이점은 `stat=\"identity\"`라는 표현이 이번에는 없다는 것입니다. `geom_bar()`를 사용할 때 `stat=\"identity\"`라는 옵션은 데이터의 숫자를 세는 `geom_bar()`가 기본값으로 가지는 행동을 억누르고, 주는 데이터를 있는 그대로 받아들이라는 뜻이라고 했지요? 그런데, `geom_line()`은 원래부터, 주는 데이터를 그대로 받아들입니다. 즉, `geom_line()`에게 `stat=\"identity\"`는 기본 옵션인 것이지요. 따라서, `stat=\"identity\"`라는 표현은 이 경우 써도 그만, 안 써도 그만 입니다.\n\n그런데, 여러분은 새로 그린 선 그래프가 막대 그래프보다 마음에 드나요? 저라면 이 경우에는 선 그래프를 추천하지 않을 것 같습니다. 나중에 데이터 스토리텔링을 이야기 하면서 좀 더 자세히 배우겠지만, 이렇게 선으로 연결된 점들을 보면, 인간의 뇌는 이 세 점 사이에 어떠한 연속성, 순서가 있는 것으로 자연스럽게 여기는 경향이 있습니다. 하지만, 위의 선 그래프에 표현된 세 개의 주 사이에는 어떠한 연속성도, 순서도 없지요. 이를, '범주형(categorical) 자료' 또는 '명목(nominal) 변수'라고 합니다. 즉, x축에 범주형 자료가 와야 할 때는 선 그래프가 잘 어울리지 않는 것이지요.\n\n그렇다면, 언제 선 그래프가 잘 어울릴까요? 여러분도 익숙하다시피, x축에 시간이 올 때 입니다. 그러면 시간 데이터를 이용한 선 그래프를 그려볼까요? 시간 데이터는 <데이터 요약하기> 장에서 한 번 다룬 바가 있습니다. 연도별 프로젝트 크기를 구하는 코드를 그대로 가져와 보도록 하지요.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprojects |> \n    mutate(year = year(date_posted)) |>\n    group_by(year) |>\n    summarise(avg_size = mean(total_price_excluding_optional_support))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 13 x 2\n    year avg_size\n   <dbl>    <dbl>\n 1  2002     609.\n 2  2003     952.\n 3  2004     435.\n 4  2005     641.\n 5  2006     693.\n 6  2007     547.\n 7  2008     443.\n 8  2009     625.\n 9  2010     484.\n10  2011     478.\n11  2012     516.\n12  2013     587.\n13  2014     626.\n```\n:::\n:::\n\n\n이제 자연스러운 '순서를 갖는' `year` 변수가 있으니, 선그래프가 적합해 보입니다. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nprojects |> \n    mutate(year = year(date_posted)) |>\n    group_by(year) |>\n    summarise(avg_size = mean(total_price_excluding_optional_support)) |>\n    ggplot() +\n    aes(x=year, y=avg_size) +\n    geom_line() +\n    geom_point()\n```\n\n::: {.cell-output-display}\n![](visualize_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\nx축에 시간이 있으니, 조금 더 익숙한 모양의 그래프가 되지요? 우리는 자연스럽게 시간에 따른 '경향(trend)'를 파악할 수 있습니다.\n\n물론 지금까지 배운 것들을 결합하면 여러개의 경향을 한 번에 표현할 수도 있습니다. <데이터 요약하기> 장에서 다룬 코드를 다시 한 번 가져와 보도록 하지요.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nprojects |> \n    mutate(year = year(date_posted)) |>\n    group_by(school_state, year) |>\n    summarise(avg_size = mean(total_price_excluding_optional_support))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'school_state'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 455 x 3\n# Groups:   school_state [52]\n   school_state  year avg_size\n   <chr>        <dbl>    <dbl>\n 1 AK            2007     380.\n 2 AK            2008     414.\n 3 AK            2009     412.\n 4 AK            2010     419.\n 5 AK            2011     442.\n 6 AK            2012     462.\n 7 AK            2013     577.\n 8 AK            2014     522.\n 9 AL            2003     339.\n10 AL            2004     546.\n# i 445 more rows\n```\n:::\n:::\n\n\n보다시피, 연도 뿐만이 아니라, 각 주에 대해서도 프로젝트 목표액 평균이 구해졌습니다. 모든 주에 대해 그래프를 그리려면 너무 많을 테니, 앞서 분석한 세 개의 주 중, 하와이(HI)와 뉴욕(NY)에 대한 데이터만 `filter()`를 이용해 서브세팅 하기로 하지요.\n\n::: {.cell}\n\n```{.r .cell-code}\nprojects |> \n    mutate(year = year(date_posted)) |>\n    group_by(school_state, year) |>\n    summarise(avg_size = mean(total_price_excluding_optional_support)) |> \n    filter(school_state %in% c(\"HI\", \"NY\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'school_state'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 21 x 3\n# Groups:   school_state [2]\n   school_state  year avg_size\n   <chr>        <dbl>    <dbl>\n 1 HI            2007     438.\n 2 HI            2008     588.\n 3 HI            2009     445.\n 4 HI            2010     564.\n 5 HI            2011     455.\n 6 HI            2012     466.\n 7 HI            2013     896.\n 8 HI            2014     730.\n 9 NY            2002     611.\n10 NY            2003     971.\n# i 11 more rows\n```\n:::\n:::\n\n\n`%in%`을 이용한 서브세팅에 주목해 보세요. 이제 Aesthetics 계층에서 x축과 연결할 데이터와 y축에 연결할 변수 뿐만 아니라, 다른 선에 연결할 변수, `school_state`도 구해졌습니다. 앞서 보았던 `group` 변수를 이용해서 다음과 같이 표현해 봅시다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprojects |> \n    mutate(year = year(date_posted)) |>\n    group_by(school_state, year) |>\n    summarise(avg_size = mean(total_price_excluding_optional_support)) |> \n    filter(school_state %in% c(\"HI\", \"NY\")) |>\n    ggplot() +\n    aes(x=year, y=avg_size) +\n    geom_line(aes(group=school_state)) +\n    geom_point()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'school_state'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output-display}\n![](visualize_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n`group=school_state`라고 써 줌으로써, `geom_line()`에게 뉴욕주는 뉴욕주끼리, 하와이주는 하와주끼리 연결하라고 한 것입니다. 하지만, 이렇게 하면 문제가 하나 있습니다. 어느 선이 어느 주인지 알 수가 없다는 것이죠. 그래서 이번에는 `group` 변수 대신에 `color` 변수를 사용해 보겠습니다. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nprojects |> \n    mutate(year = year(date_posted)) |>\n    group_by(school_state, year) |>\n    summarise(avg_size = mean(total_price_excluding_optional_support)) |> \n    filter(school_state %in% c(\"HI\", \"NY\")) |>\n    ggplot() +\n    aes(x=year, y=avg_size) +\n    geom_line(aes(color=school_state)) +\n    geom_point()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'school_state'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output-display}\n![](visualize_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n좀 더 명확하지요? 단, 점은 검은 색이라서 어색하긴 합니다. 왜냐하면 앞서 이야기 한 것처럼 `color`변수에 대한 설정을 `geom_line()`에만 적용하고, `geom_point()`에는 적용되지 않았기 때문입니다. 이럴 때에는 `color=school_state`를 ggplot 전체에 적용되는 Aesthetics 계층으로 옮겨주면 됩니다. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nprojects |> \n    mutate(year = year(date_posted)) |>\n    group_by(school_state, year) |>\n    summarise(avg_size = mean(total_price_excluding_optional_support)) |> \n    filter(school_state %in% c(\"HI\", \"NY\")) |>\n    ggplot() +\n    aes(x=year, y=avg_size, color=school_state) +\n    geom_line() +\n    geom_point()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'school_state'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output-display}\n![](visualize_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n요즘에는 그럴 일이 별로 없지만, 만약 흑백 매체라면, 이렇게 그룹별로 색깔만 달리한 그래프는 차이를 표현해 주지 못하겠지요? 그럴 때는 `linetype`, `shape`과 같은 변수를 이용하면 됩니다. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nprojects |> \n    mutate(year = year(date_posted)) |>\n    group_by(school_state, year) |>\n    summarise(avg_size = mean(total_price_excluding_optional_support)) |> \n    filter(school_state %in% c(\"HI\", \"NY\")) |>\n    ggplot() +\n    aes(x=year, y=avg_size, linetype=school_state, shape=school_state) +\n    geom_line() +\n    geom_point()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'school_state'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output-display}\n![](visualize_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n## 산포도와 상관관계 표현.\n막대 그래프는 하나의 축이 범주형 자료를 표현할 때, 선 그래프는 하나의 축이 시간을 표현할 때 사용하는 것이 좋다고 하였습니다. 두 경우 모두 나머지 하나의 축은 연속적인 숫자, 즉, 금액을 나타내었지요. 그런데, 만약 두 변수 모두 연속적인 변수라면 어떤 그래프를 사용할까요? 여러 방법이 있지만, 산포도(scatters plot)을 이용해서 두 연속형 변수 간의 상관관계(correlation)을 찾아내는 것이 일반적입니다. 산포도란, 데이터에 포함된 두 개의 변수를 x축 y축 상의 점으로 모두 표현해준 것을 의미합니다. 사실 `ggplot2`의 관점에서는 이미 사용해본 `geom_point()`를 활용한다는 것 이상의 의미를 가지지 않습니다. \n\n이번에는 크라우드펀딩 프로젝트를 통해 수혜를 얻는 학생의 수(`students_reached`)와 프로젝트 목표액 간에 상관관계가 있는지 알아보도록 하지요. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nprojects |>\n    filter(total_price_excluding_optional_support < 1000 & students_reached < 500) |>\n    sample_n(500) |>\n    ggplot() +\n    aes(x=students_reached, y=total_price_excluding_optional_support) +\n    geom_point(alpha=0.3, stroke=NA)\n```\n\n::: {.cell-output-display}\n![](visualize_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n간단하지요? 편의상 포함한 `filter()` 부분과 `sample_n()` 부분을 제외하면, `x`와 `y`만 정해준 후, `geom_point()`를 이용하면 됩니다. `filter()`를 이용해 서브세팅을 한 이유는 크라우드펀딩 프로젝트 치고는 너무 큰 (목표액이 너무 크거나, 수혜를 입는 학생들이 너무 많은) 예외적인 경우를 제외해주기 위해서입니다. `sample_n(500)`은 전체 데이터에서 500개 행만 무작위로 뽑아달라는 의미입니다. 둘 다 꼭 해야 한다기 보다는 보기 좋은 그래프를 그리기 위한 편의상의 선택입니다.\n\n마찬가지 이유로 `geom_point()` 안에 옵션도 추가했습니다. `alpha=0.3`이라는 옵션은 산포도에 찍히는 점들을 투명하게 만들어주기 위한 것입니다. 숫자가 작을수록 투명해지는 것이고, `alpha=1`이 되면 완전히 불투명해 지는 것이지요. `stroke=NA`는 각 점의 테두리를 없애주기 위한 옵션입니다. \n\n자 두 변수 간에 상관 관계가 있는 것처럼 보이나요? 제 눈에는 별로 그렇게 보이지 않는데요, 이 상관관계 역시 시각적으로 표현할 수 있습니다. 위의 그래프에 하나의 계층만 추가하면 됩니다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprojects |>\n    filter(total_price_excluding_optional_support < 1000 & students_reached < 500) |>\n    sample_n(500) |>\n    ggplot() +\n    aes(x=students_reached, y=total_price_excluding_optional_support) +\n    geom_point(alpha=0.3, stroke=NA) +\n    geom_smooth(method = lm, se = FALSE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](visualize_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n여기서는 `geom_smooth()`라는 하나의 Geometries 계층만을 추가했습니다. 간단하게 상관관계를 직선으로 표현하고 있는데요, 우리 눈에 명확하지는 않지만, 양의 기울기를 갖는 것을 수혜를 입는 학생 수가 늘 수록, 프로젝트 목표액이 조금 느는 경향이 있는 것 같네요.\n\n`geom_smooth()`에도 옵션을 사용했는데요, `method=lm`은 상관관계를 곡선이 아닌 직선으로(Linear Model) 표현해달라는 것이고, `se=FALSE`는 상관관계를 나타내는 해당 직선의 불확실성을 시각화하지 말라는 옵션입니다. 불확실성을 표현한다는 것이 무엇인지 확인하고 싶으시다면, 이 옵션을 `TRUE`로 바꿔서 다시 한 번 시각화 해 보세요.\n\n## 시각화를 위한 데이터 처리 워크플로우\n\n*그래프에서부터 뒤로 만들어나가는 것이라는 것 설명하기.*\n",
    "supporting": [
      "visualize_files\\figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}